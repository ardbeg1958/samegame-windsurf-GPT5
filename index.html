<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Same Game - UI Mock</title>
  <style>
    :root {
      --bg: #f7f8ff;
      --panel: #ffffff;
      --text: #2b2f42;
      --muted: #5b6aa5;
      --accent: #6c8bff;
      --cell-size: clamp(28px, 5.2vw, 44px);
      --gap: 6px;
      --radius: 10px;
      --speed: .18s;

      /* piece colors */
      --c-red: #ff5b6e;
      --c-teal: #1cc1b8;
      --c-blue: #4b84ff;
      --c-green: #27cc6c;
      --c-yellow: #ffd24d;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; padding: 0;
      background: radial-gradient(1200px 700px at 20% -10%, #fffbf4, transparent),
                  radial-gradient(1000px 600px at 110% 0%, #f2f8ff, transparent),
                  linear-gradient(180deg, #f7f8ff, #fff9fb 60%, #f7fffb);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", "Helvetica Neue", Arial, sans-serif;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 16px;
      min-height: 100svh;
    }

    header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 16px; gap: 12px;
      background: color-mix(in srgb, var(--panel) 80%, #f0f3ff 20%);
      border-bottom: 1px solid #e3e7ff;
      backdrop-filter: blur(6px);
    }
    .brand { display: flex; align-items: center; gap: 10px; }
    .brand .logo {
      width: 28px; height: 28px; border-radius: 8px;
      display: grid; place-items: center;
      background: linear-gradient(135deg, #6c8bff, #a07bff);
      color: white; font-weight: 700;
      letter-spacing: .5px;
      box-shadow: 0 6px 16px rgba(108,139,255,.35);
    }
    h1 { font-size: 16px; margin: 0; font-weight: 700; }

    .toolbar { display: flex; align-items: center; gap: 10px; }
    .score {
      background: #f2f4ff; border: 1px solid #d7ddff; color: var(--text);
      padding: 8px 12px; border-radius: 8px; font-variant-numeric: tabular-nums;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    .select {
      appearance: none;
      background: #ffffff; border: 1px solid #d7ddff; color: var(--text);
      padding: 6px 8px; border-radius: 8px; font-size: 13px;
      box-shadow: 0 1px 2px rgba(0,0,0,.04) inset;
    }
    .btn {
      appearance: none; border: none; cursor: pointer; color: white;
      padding: 10px 14px; border-radius: 10px; font-weight: 700;
      background: linear-gradient(180deg, #7a95ff, #5b79ff);
      box-shadow: 0 6px 16px rgba(108,139,255,.35), 0 0 0 1px rgba(255,255,255,.06) inset;
      transition: transform var(--speed) ease, filter var(--speed) ease;
    }
    .btn:active { transform: translateY(1px) scale(.99); }

    main { display: grid; place-items: center; padding: 6px 14px 20px; }

    .board-wrap {
      width: min(92vw, 560px);
      background: #ffffff;
      border: 1px solid #e2e6ff;
      border-radius: 16px;
      padding: 14px 14px 18px;
      box-shadow: 0 10px 30px rgba(88, 100, 200, .15), inset 0 0 0 1px rgba(255,255,255,.6);
    }
    .legend { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; color: var(--muted); font-size: 12px; }
    .legend .dot { width: 10px; height: 10px; border-radius: 999px; }

    .board {
      display: grid;
      grid-template-columns: repeat(10, var(--cell-size));
      grid-auto-rows: var(--cell-size);
      gap: var(--gap);
      justify-content: center;
      width: 100%;
      padding: 8px;
      border-radius: var(--radius);
      background: linear-gradient(180deg, #f6f8ff, #f9fbff);
      box-shadow: inset 0 0 0 1px rgba(30, 40, 90, .05);
    }

    .cell {
      width: var(--cell-size); height: var(--cell-size);
      display: grid; place-items: center; border-radius: 12px;
      background: #ffffff;
      box-shadow: inset 0 0 0 1px rgba(30, 40, 90, .06);
      position: relative;
      overflow: hidden;
    }
    .piece {
      width: 72%; height: 72%;
      display: grid; place-items: center;
      transition: transform var(--speed) ease, box-shadow var(--speed) ease, opacity var(--speed) ease;
      will-change: transform, opacity;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,.35));
    }
    .cell:hover .piece { transform: scale(1.05); }

    /* highlight for deletable group */
    .cell.highlight .piece {
      transform: scale(1.08);
      box-shadow: 0 6px 14px rgba(0,0,0,.25);
    }
    .cell.highlight::after {
      content: "";
      position: absolute; inset: 0; border-radius: 12px;
      box-shadow: 0 0 0 2px rgba(108,139,255,.35) inset;
      pointer-events: none;
    }

    /* fade out for removal */
    .piece.vanish { opacity: 0; transform: scale(.85); }

    /* shapes */
    .circle { border-radius: 999px; background: var(--c-red); }
    .triangle {
      width: 0; height: 0;
      border-left: 14px solid transparent;
      border-right: 14px solid transparent;
      border-bottom: 24px solid var(--c-teal);
      transform: translateY(2px);
      filter: drop-shadow(0 4px 8px rgba(0,0,0,.35));
    }
    .square { border-radius: 8px; background: var(--c-blue); }
    .diamond { transform: rotate(45deg); border-radius: 6px; background: var(--c-green); }

    /* Diamond should scale on hover (keep rotation), to avoid confusion with square */
    .cell:hover .diamond { transform: rotate(45deg) scale(1.05); }
    .star {
      --s: var(--c-yellow);
      width: 0; height: 0; position: relative; filter: drop-shadow(0 4px 8px rgba(0,0,0,.35));
    }
    .star:before, .star:after {
      content: ""; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);
      width: 0; height: 0; border-left: 12px solid transparent; border-right: 12px solid transparent;
      border-bottom: 24px solid var(--s);
    }
    .star:after { transform: translate(-50%,-50%) rotate(180deg); }

    footer {
      color: var(--muted); font-size: 12px; padding: 0 16px 16px; text-align: center;
    }

    /* End game overlay */
    .overlay {
      position: fixed; inset: 0; display: grid; place-items: center;
      background: rgba(245, 248, 255, .65);
      backdrop-filter: blur(6px);
      opacity: 0; pointer-events: none; transition: opacity var(--speed) ease;
      z-index: 10;
    }
    .overlay.show { opacity: 1; pointer-events: auto; }
    .modal {
      width: min(92vw, 420px);
      background: #ffffff;
      border: 1px solid #e0e6ff; border-radius: 16px;
      box-shadow: 0 20px 60px rgba(88,100,200,.25);
      padding: 22px 20px 18px; text-align: center;
      color: var(--text);
    }
    .modal h2 { margin: 0 0 8px; font-size: 20px; }
    .modal p { margin: 0 0 16px; color: var(--muted); }
    .modal .actions { display: flex; justify-content: center; gap: 10px; }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo">SG</div>
      <h1>Same Game</h1>
    </div>
    <div class="toolbar">
      <label for="sizeSelect" class="size-label" style="color: var(--muted); font-size: 12px;">サイズ:</label>
      <select id="sizeSelect" class="select" aria-label="盤面サイズ">
        <option value="10x10" selected>10×10</option>
        <option value="10x15">10×15</option>
        <option value="15x10">15×10</option>
        <option value="15x15">15×15</option>
      </select>
      <div class="score" aria-live="polite">Score: 0</div>
      <button class="btn" type="button">新しいゲーム</button>
    </div>
  </header>

  <main>
    <div class="board-wrap" role="region" aria-label="ゲーム盤">
      <div class="legend">
        <span>ピース種類:</span>
        <span class="dot" style="background: var(--c-red);"></span>
        <span class="dot" style="background: var(--c-teal);"></span>
        <span class="dot" style="background: var(--c-blue);"></span>
        <span class="dot" style="background: var(--c-green);"></span>
        <span class="dot" style="background: var(--c-yellow);"></span>
      </div>
      <div class="board" id="board" aria-label="盤面"></div>
      <div id="status" style="text-align:center; color: var(--muted); margin-top: 10px; font-size: 13px;">プレイ中：同じ色が2つ以上つながったグループをクリック/タップで削除できます</div>
    </div>
  </main>

  <!-- End game overlay -->
  <div class="overlay" id="overlay" aria-hidden="true" role="dialog" aria-modal="true" inert>
    <div class="modal">
      <h2>ゲーム終了</h2>
      <p>削除可能なグループはありません。</p>
      <div class="actions">
        <button class="btn" type="button" id="overlayNewGame">新しいゲーム</button>
      </div>
    </div>
  </div>

  <footer>
    © 2025 Same Game Mock UI
  </footer>

  <script>
    // Same Game implementation (Step 1: core logic, Step 2: highlight, Step 3: simple animations)
    let COLS = 10; // default width
    let ROWS = 10; // default height
    const TYPES = 5; // number of piece types
    const SCORE_UNIT = 10;

    let board = []; // 2D array (ROWS x COLS), values: 0..TYPES-1 or null
    let score = 0;
    let gameState = 'playing'; // 'playing' | 'ended'
    let hoverGroup = null; // array of [r,c]

    const boardEl = document.getElementById('board');
    const scoreEl = document.querySelector('.score');
    const statusEl = document.getElementById('status');
    const newGameBtn = document.querySelector('.btn');
    const sizeSelect = document.getElementById('sizeSelect');
    const overlayEl = document.getElementById('overlay');
    const overlayBtn = document.getElementById('overlayNewGame');

    newGameBtn.addEventListener('click', () => newGame());
    overlayBtn.addEventListener('click', () => newGame());
    sizeSelect.addEventListener('change', () => {
      const [r, c] = sizeSelect.value.split('x').map(Number);
      ROWS = r; COLS = c;
      newGame();
    });

    function randInt(n) { return Math.floor(Math.random() * n); }
    function createDiv(cls) { const el = document.createElement('div'); el.className = cls; return el; }

    function createRandomBoard(rows, cols, types) {
      const b = new Array(rows);
      for (let r = 0; r < rows; r++) {
        b[r] = new Array(cols);
        for (let c = 0; c < cols; c++) {
          b[r][c] = randInt(types);
        }
      }
      return b;
    }

    function updateGridMetrics() {
      // Always reflect current column count in grid style
      boardEl.style.gridTemplateColumns = `repeat(${COLS}, var(--cell-size))`;
      // Fit cells to container width so columns don't overflow
      const rootStyles = getComputedStyle(document.documentElement);
      const gapPx = parseFloat(rootStyles.getPropertyValue('--gap')) || 6;
      const boardPaddingLR = 16; // .board has padding: 8px on each side
      const container = boardEl.parentElement; // .board-wrap
      let containerContentWidth = boardEl.clientWidth;
      if (container) {
        const cs = getComputedStyle(container);
        const pl = parseFloat(cs.paddingLeft) || 0;
        const pr = parseFloat(cs.paddingRight) || 0;
        // clientWidth already includes padding, so subtract to get content box width
        containerContentWidth = container.clientWidth - (pl + pr);
      }
      const available = containerContentWidth - boardPaddingLR - gapPx * (COLS - 1);
      if (available > 0) {
        const raw = Math.floor(available / COLS);
        const clamped = Math.max(28, Math.min(44, raw)); // keep within design range
        boardEl.style.setProperty('--cell-size', `${clamped}px`);
      }
    }

    function renderBoard() {
      updateGridMetrics();
      // Rebuild cells when empty or count mismatches the current ROWS*COLS
      if (boardEl.childElementCount !== ROWS * COLS) {
        boardEl.innerHTML = '';
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const cell = createDiv('cell');
            cell.dataset.row = String(r);
            cell.dataset.col = String(c);
            // event listeners
            cell.addEventListener('mouseenter', onCellEnter);
            cell.addEventListener('mouseleave', onCellLeave);
            cell.addEventListener('click', onCellClick);
            cell.addEventListener('touchstart', onCellEnter, { passive: true });
            cell.addEventListener('touchend', onCellLeave, { passive: true });
            const piece = createDiv('piece');
            cell.appendChild(piece);
            boardEl.appendChild(cell);
          }
        }
      }

      // Update pieces
      const cells = boardEl.children; let idx = 0;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++, idx++) {
          const cell = cells[idx];
          const piece = cell.firstElementChild;
          cell.classList.remove('highlight');
          piece.className = 'piece';
          piece.style.opacity = '';
          if (board[r][c] == null) {
            piece.style.opacity = '0';
          } else {
            const t = board[r][c];
            applyTypeClass(piece, t);
          }
        }
      }
      // ensure metrics after potential DOM changes
      updateGridMetrics();
    }

    function applyTypeClass(pieceEl, type) {
      // map types to shape classes: 0 circle, 1 triangle, 2 square, 3 diamond, 4 star
      const classes = ['circle','triangle','square','diamond','star'];
      pieceEl.classList.add(classes[type]);
    }

    function updateScore() {
      scoreEl.textContent = `Score: ${score}`;
    }

    function inBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }

    function findGroup(sr, sc) {
      const start = board[sr][sc];
      if (start == null) return [];
      const q = [[sr, sc]];
      const seen = new Set([`${sr},${sc}`]);
      const out = [];
      while (q.length) {
        const [r, c] = q.shift();
        out.push([r, c]);
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for (const [dr, dc] of dirs) {
          const nr = r + dr, nc = c + dc;
          if (!inBounds(nr, nc)) continue;
          const key = `${nr},${nc}`;
          if (seen.has(key)) continue;
          if (board[nr][nc] === start) { seen.add(key); q.push([nr, nc]); }
        }
      }
      return out;
    }

    function removeGroup(group) {
      // Step 3: fade animation, then remove
      const cells = boardEl.children;
      for (const [r, c] of group) {
        const idx = r * COLS + c;
        const piece = cells[idx].firstElementChild;
        piece.classList.add('vanish');
      }
      // After transition, nullify and proceed
      const delay = 180; // ms, aligned with --speed
      return new Promise(resolve => setTimeout(() => {
        for (const [r, c] of group) board[r][c] = null;
        resolve();
      }, delay));
    }

    function applyGravity() {
      for (let c = 0; c < COLS; c++) {
        let write = ROWS - 1;
        for (let r = ROWS - 1; r >= 0; r--) {
          if (board[r][c] != null) {
            if (write !== r) { board[write][c] = board[r][c]; board[r][c] = null; }
            write--;
          }
        }
      }
    }

    function shiftColumns() {
      let write = 0;
      for (let c = 0; c < COLS; c++) {
        // check if column has any non-null
        let has = false;
        for (let r = 0; r < ROWS; r++) if (board[r][c] != null) { has = true; break; }
        if (has) {
          if (write !== c) {
            for (let r = 0; r < ROWS; r++) { board[r][write] = board[r][c]; board[r][c] = null; }
          }
          write++;
        }
      }
    }

    function hasAnyMoves() {
      const seen = new Set();
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c] == null) continue;
          const key = `${r},${c}`; if (seen.has(key)) continue;
          const g = findGroup(r, c);
          for (const [gr, gc] of g) seen.add(`${gr},${gc}`);
          if (g.length >= 2) return true;
        }
      }
      return false;
    }

    function onCellEnter(e) {
      if (gameState !== 'playing') return;
      const cell = e.currentTarget;
      const r = Number(cell.dataset.row), c = Number(cell.dataset.col);
      if (board[r][c] == null) return;
      const g = findGroup(r, c);
      clearHighlights();
      if (g.length >= 2) {
        hoverGroup = g;
        highlightGroup(g);
      } else {
        hoverGroup = null;
      }
    }

    function onCellLeave() {
      hoverGroup = null;
      clearHighlights();
    }

    function onCellClick(e) {
      if (gameState !== 'playing') return;
      const cell = e.currentTarget;
      const r = Number(cell.dataset.row), c = Number(cell.dataset.col);
      const g = findGroup(r, c);
      if (g.length < 2) return;
      // score
      score += g.length * g.length * SCORE_UNIT;
      updateScore();
      // animate + remove -> gravity -> shift -> rerender -> check end
      removeGroup(g).then(() => {
        applyGravity();
        shiftColumns();
        renderBoard();
        if (!hasAnyMoves()) endGame();
      });
    }

    function highlightGroup(group) {
      const cells = boardEl.children;
      for (const [r, c] of group) {
        const idx = r * COLS + c;
        cells[idx].classList.add('highlight');
      }
    }

    function clearHighlights() {
      const cells = boardEl.children;
      for (let i = 0; i < cells.length; i++) cells[i].classList.remove('highlight');
    }

    function endGame() {
      gameState = 'ended';
      statusEl.textContent = 'ゲーム終了：削除可能なグループはありません';
      overlayEl.classList.add('show');
      overlayEl.removeAttribute('inert');
      overlayEl.setAttribute('aria-hidden', 'false');
      // move focus into the dialog for SR users
      requestAnimationFrame(() => overlayBtn.focus());
    }

    function newGame() {
      // Clear board DOM so that cell count matches new size
      boardEl.innerHTML = '';
      board = createRandomBoard(ROWS, COLS, TYPES);
      score = 0; gameState = 'playing';
      statusEl.textContent = 'プレイ中：同じ色が2つ以上つながったグループをクリック/タップで削除できます';
      // ensure focus is not inside the dialog before hiding it
      overlayBtn.blur();
      newGameBtn.focus();
      overlayEl.classList.remove('show');
      overlayEl.setAttribute('aria-hidden', 'true');
      overlayEl.setAttribute('inert', '');
      // DOM will be rebuilt by renderBoard()
      renderBoard();
      updateScore();
    }

    // handle window resize to keep grid fitted
    window.addEventListener('resize', () => updateGridMetrics());

    // init
    newGame();
  </script>
</body>
</html>
